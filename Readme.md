
для выражений типа [:printed:]

можно делать интересные штуки типа бинарной арифметики
- пользовтель добавляет свой [:something:]
- в его конфиге указывает match функцию, которая говорит ок или не ок

один из примеров xor на бинарное представление rune

- так пример можно будет расширить для других кодировок и range table-ов
- возможны регулярные выражения для бинарных данных

###

что не так - есть два пути, один более оптимальный
		
первый заключается в написании структуры куда добавляются вообще все метчи что есть, а потом достаются только "самые самые"
- что-то вроде очереди с приоритетами или дерева отрезков
- второй заключается в хитром хранении только "самых самых" метчей:
- загвоздка заключается в том, что непонятно как еще на этапе сканирования определить что метч оптимальный (и возможно ли это вообще непонятно)
- непонятно как избегать повторные сканирования

		// как вариант идти сначала по первому, зафиксировать поведение тестами, а потом уже оптимизироваться

		// есть сомнения - у регулярных выражений принято "жадное" поведение, то есть берется всегда самый первый и самый большой метч
		// это не совсем поведение interval tree

		// по идее для оптимизации нужно сделать немного
		// - научиться определять матчилась ли нода в заданом интервале
		// - научиться определять с какой позиции матчить текущую ноду, если она уже матчилась (только для root)

		// https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t

		// https://www.regular-expressions.info/engine.html
		// This is a very important point to understand: a regex engine always returns the leftmost match, even if a “better” match could be found later.
